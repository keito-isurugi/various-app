/**
 * src/data/explanations/binary-search-explanation.ts
 *
 * 二分探索の解説データ
 * プログラミング学習者向けのわかりやすい説明
 */

import type { ExplanationData } from "@/types/algorithm";

/**
 * 二分探索の解説データ
 * アルゴリズムの基本概念から実装まで段階的に説明
 */
export const binarySearchExplanation: ExplanationData = {
	calculationType: "binary_search",
	title: "二分探索アルゴリズムとは？",
	overview:
		"二分探索は、ソート済みの配列から目的の要素を効率的に見つけるアルゴリズムです。毎回探索範囲を半分に減らすことで、大量のデータからでも高速に検索できます。辞書で単語を探すときと同じ原理で、プログラミングでは最も基本的で重要なアルゴリズムの一つです。",

	sections: [
		{
			id: "basic-concept",
			title: "【基礎】基本的な考え方",
			content:
				"二分探索の考え方は、普段私たちが辞書で単語を探すときと全く同じです。辞書で「Programming」という単語を探すとき、最初からページをめくったりしませんよね？まず真ん中あたりを開いて、目的の単語がそれより前にあるか後にあるかを判断し、該当する半分でさらに同じことを繰り返します。",
			importance: "high",
			examples: [
				"辞書で単語を探す：真ん中→前半/後半→さらに真ん中...",
				"電話帳で人名を探す：アルファベット順で範囲を絞り込み",
				"図書館で本を探す：分類番号で段階的に絞り込み",
			],
		},

		{
			id: "algorithm-steps",
			title: " アルゴリズムの手順",
			content:
				"二分探索は以下の簡単な手順を繰り返します：1) 配列の中央要素を見る、2) 目標値と比較する、3) 目標値が小さければ左半分、大きければ右半分を選ぶ、4) 選んだ半分で同じ処理を繰り返す。このシンプルな手順だけで、非常に効率的な検索が実現できます。",
			importance: "high",
			examples: [
				"ステップ1：配列 [1,3,5,7,9] で 7 を探す",
				"ステップ2：中央の 5 と比較 → 7は右側",
				"ステップ3：[7,9] の中央 7 と比較 → 発見！",
			],
		},

		{
			id: "time-complexity",
			title: "【計算量】なぜこんなに速いの？",
			content:
				"二分探索の驚くべき効率性は「毎回半分に減る」ことにあります。1000個の要素があっても、1回目で500個、2回目で250個、3回目で125個...と減っていき、最大でも10回程度の比較で見つかります。これを数学的には「対数時間 O(log n)」と表現します。",
			formula:
				"時間計算量: O(log n)<br>空間計算量: O(1)<br><br>n = 配列の要素数<br>log₂(1000) ≈ 10回の比較",
			importance: "medium",
			examples: [
				"100万個の要素でも最大20回の比較で発見",
				"線形探索なら平均50万回、二分探索なら平均10回",
				"データが大きくなるほど効果は絶大",
			],
		},

		{
			id: "prerequisite",
			title: " 重要な前提条件",
			content:
				"二分探索には重要な前提条件があります：「配列がソートされていること」です。これは辞書が50音順やアルファベット順になっているのと同じ理由です。順序がバラバラだと、中央の要素を見ても左右のどちらを選ぶべきかわからないからです。",
			importance: "high",
			examples: [
				"ソート済み: [1,3,5,7,9] → 二分探索可能",
				"未ソート: [5,1,9,3,7] → 二分探索不可能",
				"ソートのコスト vs 検索回数のトレードオフ",
			],
		},

		{
			id: "real-world-examples",
			title: " 実世界での応用例",
			content:
				"二分探索は私たちの身の回りで広く使われています。データベースのインデックス検索、ファイルシステムの検索、ゲームの高得点ランキング、在庫管理システムなど、ソートされたデータを扱うあらゆる場面で活用されています。",
			importance: "medium",
			examples: [
				"Google検索：インデックスされたWebページから高速検索",
				"ECサイト：価格順や評価順での商品検索",
				"ゲーム：スコアランキングでの順位検索",
				"GPS：地図データからの最適ルート検索",
			],
		},

		{
			id: "implementation-tips",
			title: " 実装のポイント",
			content:
				"二分探索を実装する際の重要なポイントは、インデックスの計算です。特に中央値の計算 `mid = (left + right) / 2` では、オーバーフローを避けるため `mid = left + (right - left) / 2` と書くのが安全です。また、境界条件（left <= right）の処理も重要です。",
			importance: "low",
			examples: [
				"境界値の処理：left <= right の条件",
				"中央値計算：オーバーフロー対策の重要性",
				"見つからない場合の戻り値：-1 や例外処理",
			],
		},

		{
			id: "variations",
			title: " 二分探索の応用",
			content:
				"基本の二分探索を応用して、「最初に現れる位置」「最後に現れる位置」「指定値以上の最小値」など、様々な検索パターンに対応できます。これらの応用テクニックを覚えると、競技プログラミングや実務での問題解決力が大幅に向上します。",
			importance: "low",
			examples: [
				"lower_bound：指定値以上の最初の要素",
				"upper_bound：指定値より大きい最初の要素",
				"重複要素がある場合の最初/最後の位置",
			],
		},
	],
};
