/**
 * src/data/explanations/segment-tree-explanation.ts
 *
 * セグメント木（Segment Tree）の解説データ
 * 範囲クエリと一点更新を効率的に処理する完全二分木の理論と実装
 */

import type { ExplanationData } from "@/types/algorithm";

/**
 * セグメント木（Segment Tree）の解説データ
 * 基本概念から高度な応用まで包括的に説明
 */
export const segmentTreeExplanation: ExplanationData = {
	calculationType: "segment_tree",
	title: "セグメント木（Segment Tree）とは？",
	overview:
		"セグメント木（Segment Tree）は、配列の範囲クエリ（区間の和、最小値、最大値など）と一点更新を効率的に処理するデータ構造です。完全二分木として実装され、分割統治法の原理に基づいて動作し、構築O(n)、クエリ・更新O(log n)の優秀な時間計算量を実現します。各ノードが特定の範囲を担当し、葉ノードは元配列の各要素に対応、内部ノードは子ノードの値を結合した値を保持します。遅延評価（Lazy Propagation）により範囲更新も効率化でき、競技プログラミングから実用システムまで幅広く応用される、範囲処理における最も重要なデータ構造の一つです。",

	sections: [
		{
			id: "tree-structure",
			title: " 完全二分木による範囲分割",
			content:
				"セグメント木は完全二分木として実装され、各ノードが配列の特定の範囲を担当します。根ノードは全体の範囲[0, n-1]を管理し、各内部ノードは担当範囲を左右に分割して子ノードに委譲します。葉ノードは単一要素の範囲を担当し、元配列の各要素に直接対応します。この分割統治的な構造により、任意の範囲クエリを効率的に処理できます。配列実装では、ノードiの左の子が2i、右の子が2i+1、親がfloor(i/2)となり、簡潔な実装が可能です。木の高さはceil(log₂n)+1となり、必要なノード数は最大4n個程度です。この構造により、O(log n)での範囲アクセスと更新が可能になり、大規模データに対しても高速な処理を実現できます。",
			importance: "high",
			examples: [
				"根ノード: 範囲[0,7]全体を管理",
				"内部ノード: [0,3]と[4,7]に分割",
				"葉ノード: [0,0], [1,1], ..., [7,7]",
				"配列実装: 親i → 左子2i, 右子2i+1",
			],
			formula:
				"木構造の性質:<br>• ノード数: 最大4n個<br>• 木の高さ: ceil(log₂n) + 1<br>• 親子関係: 親i <-> 左子2i, 右子2i+1<br>• 範囲分割: [l,r] → [l,mid], [mid+1,r]",
		},

		{
			id: "range-query-processing",
			title: "【詳細】範囲クエリの効率的処理",
			content:
				"セグメント木の範囲クエリは、分割統治法により効率的に処理されます。クエリ範囲[ql, qr]に対して、各ノードの担当範囲[l, r]との関係を判定し、完全に含まれる場合はそのノードの値を使用、部分的に重複する場合は子ノードを再帰的に探索、全く重複しない場合はスキップします。この処理により、必要最小限のノードのみを訪問し、O(log n)の時間計算量を実現します。結合演算は、和、最小値、最大値、GCD、LCMなど様々な結合可能な演算に対応でき、単位元を適切に設定することで正しい結果を得られます。また、クエリの処理過程で訪問するノード数は最大O(log n)個に制限され、効率的な実装が可能です。",
			importance: "high",
			examples: [
				"完全包含: ノード範囲がクエリ範囲に完全に含まれる",
				"部分重複: ノード範囲とクエリ範囲が部分的に重複",
				"範囲外: ノード範囲がクエリ範囲と全く重複しない",
				"訪問ノード: 最大O(log n)個のノードを探索",
			],
			formula:
				"範囲クエリアルゴリズム:<br>function query(node, l, r, ql, qr):<br>&nbsp;&nbsp;if qr < l or ql > r: return IDENTITY<br>&nbsp;&nbsp;if ql ≤ l and r ≤ qr: return tree[node]<br>&nbsp;&nbsp;mid = (l + r) / 2<br>&nbsp;&nbsp;return combine(query(left), query(right))",
		},

		{
			id: "point-update",
			title: "【まとめ】一点更新と伝播処理",
			content:
				"セグメント木の一点更新は、指定されたインデックスの値を変更し、影響を受ける全てのノードを更新する処理です。更新は葉ノードから開始し、根ノードまでのパス上の全てのノードで値を再計算します。このパスの長さは木の高さに等しいため、時間計算量はO(log n)となります。更新処理では、現在のノードが更新対象を含むかを判定し、含む場合は適切な子ノードに進み、葉に到達したら値を更新してから親方向に戻りながら各ノードの値を再計算します。この処理により、一つの要素の変更が効率的に木全体に反映され、後続のクエリで正しい結果を得ることができます。配列の直接更新と比較して、範囲クエリ性能を犠牲にすることなく更新処理を実現できます。",
			importance: "high",
			examples: [
				"更新パス: 葉ノードから根ノードまでの経路",
				"影響範囲: パス上の全ノードで値を再計算",
				"時間計算量: O(log n) - 木の高さに比例",
				"一貫性: 更新後も全ての範囲クエリが正しい結果",
			],
			formula:
				"一点更新アルゴリズム:<br>function update(node, l, r, pos, val):<br>&nbsp;&nbsp;if l == r: tree[node] = val<br>&nbsp;&nbsp;else:<br>&nbsp;&nbsp;&nbsp;&nbsp;mid = (l + r) / 2<br>&nbsp;&nbsp;&nbsp;&nbsp;update(child, pos, val)<br>&nbsp;&nbsp;&nbsp;&nbsp;tree[node] = combine(left, right)",
		},

		{
			id: "lazy-propagation",
			title: "遅延評価による範囲更新",
			content:
				"遅延評価（Lazy Propagation）は、範囲更新を効率的に処理するための高度な技法です。範囲更新では、指定された範囲の全要素に対して同じ操作（加算、乗算、代入など）を実行しますが、単純に実装すると1つの更新でO(n log n)の時間がかかります。遅延評価では、更新情報を即座に適用せず、各ノードに「遅延タグ」として保存し、実際にそのノードの値が必要になったときに適用します。これにより、範囲更新をO(log n)で実行でき、クエリ時に必要に応じて遅延情報を子ノードに伝播させます。この技法により、大量の範囲更新と範囲クエリが混在する問題でも高速に処理できます。遅延評価は実装が複雑になりますが、性能向上の効果は非常に大きいです。",
			importance: "medium",
			examples: [
				"範囲加算: 区間[l,r]の全要素にvを加算",
				"遅延タグ: 各ノードに未適用の更新情報を保存",
				"伝播処理: 必要時に子ノードへ遅延情報を転送",
				"時間短縮: O(n log n) → O(log n)に改善",
			],
			formula:
				"遅延評価の流れ:<br>1. 更新: lazy[node] に情報を保存<br>2. クエリ時: lazy情報を子に伝播<br>3. 適用: 実際の値に遅延情報を反映<br><br>範囲更新: O(log n)<br>クエリ: O(log n) + 伝播コスト",
		},

		{
			id: "supported-operations",
			title: "【実装】サポートする演算と単位元",
			content:
				"セグメント木は、結合法則を満たす様々な演算をサポートします。代表的な演算として、和（Sum）、最小値（Min）、最大値（Max）、最大公約数（GCD）、最小公倍数（LCM）、ビット演算（AND, OR, XOR）などがあります。各演算には適切な単位元（恒等元）を設定する必要があり、和なら0、最小値なら無限大、最大値なら負の無限大、GCDなら0、ANDなら全ビット立った値などを使用します。また、演算が結合法則と交換法則を満たすことで、分割統治的な計算が正しく動作します。カスタム演算を定義する場合は、これらの数学的性質を満たすことを確認する必要があります。複数の演算を同時に管理する多次元セグメント木や、複素数演算なども実装可能で、応用範囲は非常に広いです。",
			importance: "medium",
			examples: [
				"和演算: combine(a,b) = a+b, identity = 0",
				"最小値: combine(a,b) = min(a,b), identity = ∞",
				"最大値: combine(a,b) = max(a,b), identity = -∞",
				"GCD演算: combine(a,b) = gcd(a,b), identity = 0",
			],
			formula:
				"演算の要件:<br>• 結合法則: (a * b) * c = a * (b * c)<br>• 単位元: a * e = e * a = a<br><br>一般的な演算:<br>• Sum: +, Min: min, Max: max<br>• GCD: gcd, LCM: lcm<br>• Bit: &, |, ⊕",
		},

		{
			id: "implementation-details",
			title: " 実装上の考慮事項",
			content:
				"セグメント木の実装では、効率性と正確性を両立させるためのいくつかの重要な考慮事項があります。配列サイズは、最悪の場合4n個のノードが必要なため、十分な容量を確保する必要があります。インデックス管理では、1-basedまたは0-basedの選択により親子関係の計算が変わるため、一貫性を保つことが重要です。再帰実装は理解しやすいですが、スタックオーバーフローの危険があるため、大きなデータでは反復実装を検討します。メモリアクセスパターンの最適化により、キャッシュ効率を向上させることができます。また、テンプレート化により様々な型と演算に対応でき、型安全性を確保できます。エラーハンドリングでは、範囲外アクセスや無効な演算の検出が重要です。これらの配慮により、理論的性能を実用的な環境でも実現できます。",
			importance: "medium",
			examples: [
				"配列サイズ: 4n個の容量を確保",
				"インデックス: 1-basedまたは0-basedの一貫性",
				"実装方式: 再帰vs反復の選択",
				"型安全性: テンプレート化とエラー処理",
			],
		},

		{
			id: "2d-segment-tree",
			title: " 二次元セグメント木",
			content:
				"二次元セグメント木は、二次元配列に対する矩形範囲クエリと一点更新を効率的に処理するデータ構造です。一次元セグメント木を二重に構成し、外側の木で行方向を、内側の木で列方向を管理します。構築はO(nm log n log m)、クエリと更新はO(log n log m)の時間計算量となり、二次元累積和テーブルと比較して更新に強い特性を持ちます。実装では、各ノードが一次元セグメント木への参照を持ち、再帰的に処理を進めます。空間計算量はO(nm)となり、大きなデータでは実用的な制限があります。画像処理での矩形領域統計、地理情報システムでの範囲検索、ゲーム開発での領域判定など、二次元データを扱う多くの分野で応用されています。座標圧縮と組み合わせることで、疎な二次元データも効率的に処理できます。",
			importance: "low",
			examples: [
				"矩形クエリ: sum(x1,y1,x2,y2)をO(log n log m)で処理",
				"二重構造: 外側行管理、内側列管理",
				"空間効率: 疎データでは座標圧縮と併用",
				"応用例: 画像統計、GIS、ゲーム領域判定",
			],
		},

		{
			id: "persistent-segment-tree",
			title: " 永続セグメント木",
			content:
				"永続セグメント木（Persistent Segment Tree）は、過去の全ての状態を保持し、任意の時点での範囲クエリを可能にするデータ構造です。更新のたびに新しいバージョンを作成しますが、変更されないノードは共有することで空間効率を実現します。一回の更新でO(log n)個の新しいノードのみが作成され、全体の空間計算量はO(m log n)（m回の更新）となります。この技法により、「k番目の更新後の状態での範囲クエリ」や「二つの異なる時点での状態比較」などが可能になります。実装では、各バージョンの根ノードを保持し、パスコピー（Path Copying）により効率的にバージョン管理を行います。関数型プログラミングの概念と深く関連し、オンラインクエリ、競技プログラミング、データベースの履歴管理などで重要な技術です。",
			importance: "low",
			examples: [
				"バージョン管理: 各更新後の状態を保持",
				"ノード共有: 変更されない部分を再利用",
				"パスコピー: O(log n)のノード作成で新バージョン",
				"時点クエリ: 特定バージョンでの範囲検索",
			],
		},

		{
			id: "competitive-programming",
			title: " 競技プログラミングでの活用",
			content:
				"セグメント木は競技プログラミングにおいて最も重要なデータ構造の一つです。Range Minimum Query (RMQ)、Range Sum Query (RSQ)、Range Maximum Query、区間更新クエリなどの典型問題で頻繁に使用されます。実装の高速化のため、テンプレート化されたライブラリを事前に用意し、問題の制約に応じて基本版、遅延評価版、永続版を使い分けます。座標圧縮、二分探索、Mo's algorithm、Heavy-Light Decompositionなど他の技法と組み合わせることで、より複雑な問題を解決できます。時間制限が厳しい問題では、定数倍の最適化（ビット演算の活用、メモリアクセスパターンの改善など）が重要になります。また、セグメント木を理解することで、より高度なデータ構造（Link-Cut Tree、Splay Treeなど）への理解も深まります。",
			importance: "medium",
			examples: [
				"典型問題: RMQ, RSQ, 区間更新クエリ",
				"実装戦略: テンプレート化とバージョン管理",
				"組み合わせ: 座標圧縮、二分探索、HLD",
				"最適化: 定数倍削減とメモリ効率",
			],
		},

		{
			id: "real-world-applications",
			title: " 実世界での応用例",
			content:
				"セグメント木は、実世界の多くのシステムで重要な役割を果たしています。データベースでは、B+木の代替として範囲クエリの最適化に使用されます。地理情報システム（GIS）では、空間インデックスとして地図上の範囲検索を高速化します。ゲーム開発では、物理シミュレーション、コリジョン検出、レベルオブディテール（LOD）管理に活用されます。金融システムでは、時系列データの範囲統計、リスク計算、取引履歴の効率的な検索に使用されます。画像・動画処理では、ピクセル値の範囲統計、ヒストグラム計算、リージョン分析で重要です。リアルタイムシステムでは、センサーデータの範囲監視、異常検出、品質管理に応用されます。これらの応用では、セグメント木の効率的な範囲処理能力が、システム全体の性能向上に大きく貢献しています。",
			importance: "low",
			examples: [
				"データベース: B+木代替の範囲インデックス",
				"GIS: 地図検索と空間インデックス",
				"ゲーム: 物理計算とコリジョン検出",
				"金融: 時系列分析とリスク計算",
			],
		},

		{
			id: "advanced-optimizations",
			title: "【計算量】高度な最適化技法",
			content:
				"セグメント木の性能は、様々な高度な最適化技法により大幅に向上させることができます。Segment Tree Beats!では、区間チャンプ値（区間の最大・最小値）を利用して、特定の範囲更新を効率化します。座標圧縮により、大きな座標空間でのメモリ使用量を削減できます。並列化では、独立したクエリを並列実行し、マルチコア環境での性能を向上させます。SIMD命令を活用することで、単一の命令で複数のデータを同時に処理できます。メモリプールやカスタムアロケータにより、動的メモリ確保のオーバーヘッドを削減できます。また、問題固有の性質を活用した特殊化（単調性、周期性など）により、さらなる高速化が可能です。これらの最適化は、大規模データや高頻度アクセスが要求される実用システムで威力を発揮します。",
			importance: "low",
			examples: [
				"Segment Tree Beats: チャンプ値による更新効率化",
				"座標圧縮: 大座標空間でのメモリ削減",
				"並列化: マルチコアでの同時処理",
				"SIMD: ベクトル命令による高速化",
			],
		},

		{
			id: "educational-significance",
			title: "【基礎】教育的意義と学習価値",
			content:
				"セグメント木は、データ構造とアルゴリズムの学習において極めて重要な教育的価値を持ちます。完全二分木の概念、分割統治法の応用、再帰的アルゴリズムの設計を具体的に学べます。計算量解析では、木の高さと操作回数の関係、償却計算量の概念を実践的に理解できます。また、抽象的な「範囲クエリ」という概念を具体的なデータ構造で実現する過程を通じて、問題抽象化と実装の架け橋を体験できます。遅延評価の学習により、効率化のための高度な技法を習得でき、永続化により関数型プログラミングの概念も学べます。さらに、他のデータ構造（BIT、平方分割、Mo's algorithmなど）との比較を通じて、問題に応じた適切なデータ構造選択の重要性を理解できます。これらの学習体験は、より高度なアルゴリズム設計への重要な基盤となります。",
			importance: "low",
			examples: [
				"木構造理解: 完全二分木と分割統治法",
				"計算量解析: 理論と実践の結合",
				"抽象化概念: 問題から実装への変換",
				"技法習得: 遅延評価と永続化",
			],
		},
	],
};
