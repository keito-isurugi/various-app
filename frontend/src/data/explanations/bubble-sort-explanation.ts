/**
 * src/data/explanations/bubble-sort-explanation.ts
 *
 * バブルソートの解説データ
 * プログラミング学習者向けのわかりやすい説明
 */

import type { ExplanationData } from "@/types/algorithm";

/**
 * バブルソートの解説データ
 * アルゴリズムの基本概念から実装まで段階的に説明
 */
export const bubbleSortExplanation: ExplanationData = {
	calculationType: "bubble_sort",
	title: "バブルソートアルゴリズムとは？",
	overview:
		"バブルソートは、隣接する要素同士を比較して、必要に応じて交換を繰り返すシンプルなソートアルゴリズムです。大きな値が水の中の泡（バブル）のように徐々に上（右端）に浮上していく様子からこの名前がつけられました。理解しやすく実装も簡単なため、プログラミング学習の最初に学ぶソートアルゴリズムです。",

	sections: [
		{
			id: "basic-concept",
			title: "🫧 基本的な考え方",
			content:
				"バブルソートの考え方は、水の中の泡が浮上する現象と似ています。配列の中で大きな値（重い泡）が隣の小さな値（軽い泡）と位置を交換しながら、最終的に右端（水面）まで移動していきます。この比較と交換を繰り返すことで、配列全体が整列されます。",
			importance: "high",
			examples: [
				"水中の泡：大きな泡が小さな泡を追い越して水面へ",
				"配列の要素：大きな値が小さな値を追い越して右端へ",
				"隣接比較：常に隣同士の要素のみを比較",
			],
		},

		{
			id: "algorithm-steps",
			title: " アルゴリズムの手順",
			content:
				"バブルソートは以下の手順を繰り返します：1) 配列の最初から隣り合う2つの要素を比較、2) 左の要素が右の要素より大きい場合は交換、3) 配列の最後まで繰り返し、4) 1回のパスで最大値が右端に移動、5) 残りの要素に対して同じ処理を繰り返します。",
			importance: "high",
			examples: [
				"パス1：[64,34,25,12,22] → 64が右端に移動",
				"パス2：[34,25,12,22,|64] → 34が右端に移動",
				"パス3：[25,12,22,|34,64] → 25が右端に移動",
			],
		},

		{
			id: "time-complexity",
			title: "️ 時間計算量と効率性",
			content:
				"バブルソートの時間計算量は O(n²) です。これは、n個の要素に対して最大 n×(n-1)/2 回の比較が必要なためです。ただし、配列が既にソートされている場合は O(n) となる最適化も可能です。空間計算量は O(1) で、元の配列以外にほとんどメモリを使用しません。",
			formula:
				"時間計算量: O(n²)<br>空間計算量: O(1)<br><br>比較回数: n×(n-1)/2<br>最良の場合: O(n) （既にソート済み）",
			importance: "medium",
			examples: [
				"10個の要素：最大45回の比較",
				"100個の要素：最大4,950回の比較",
				"大規模データには不向き（効率が悪い）",
			],
		},

		{
			id: "stability",
			title: " 安定性の特徴",
			content:
				"バブルソートは「安定ソート」です。これは、同じ値を持つ要素の相対的な順序が変わらないことを意味します。隣接する要素のみを比較し、等しい場合は交換しないため、元の順序が保たれます。この特性は、複数の条件でソートする際に重要です。",
			importance: "medium",
			examples: [
				"同じ値の要素：相対的な順序が保持される",
				"複数条件ソート：第1条件でソート後、第2条件でソート",
				"データの整合性：元の順序情報が失われない",
			],
		},

		{
			id: "optimization",
			title: "【計算量】最適化のテクニック",
			content:
				"バブルソートにはいくつかの最適化方法があります。最も重要なのは「早期終了」です。1回のパスで交換が1回も発生しなかった場合、配列は既にソートされているため、処理を終了できます。また、各パスで右端の要素は確定するため、比較範囲を縮小できます。",
			importance: "low",
			examples: [
				"早期終了：交換がない場合は処理完了",
				"範囲縮小：確定した要素は比較対象から除外",
				"最良ケース：既にソート済みなら O(n) で完了",
			],
		},

		{
			id: "practical-use",
			title: "実用性と教育的価値",
			content:
				"バブルソートは実際の開発ではほとんど使用されませんが、教育的価値は非常に高いです。アルゴリズムの基本概念、ループの入れ子構造、配列の操作、時間計算量の理解などを学ぶのに最適です。また、他のソートアルゴリズムの理解の基礎となります。",
			importance: "medium",
			examples: [
				"教育目的：プログラミング学習の第一歩",
				"概念理解：ソートアルゴリズムの基本原理",
				"デバッグ：動作が分かりやすく、問題を発見しやすい",
			],
		},

		{
			id: "comparison",
			title: " 他のソートアルゴリズムとの比較",
			content:
				"バブルソートは他のソートアルゴリズムと比較すると効率は劣りますが、理解しやすさでは優れています。選択ソートや挿入ソートも O(n²) ですが、実装の複雑さや安定性が異なります。クイックソートやマージソートは O(n log n) でより高速ですが、実装が複雑です。",
			importance: "low",
			examples: [
				"選択ソート：O(n²)、不安定、実装やや複雑",
				"挿入ソート：O(n²)、安定、部分的にソート済みで高速",
				"クイックソート：O(n log n)、不安定、実装複雑",
			],
		},
	],
};
