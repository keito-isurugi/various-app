# M-1グランプリ分析アプリ 要件定義書

## 1. 概要

### 1.1 目的
M-1グランプリの過去データを様々な切り口で集計・分析し、閲覧できるWebアプリケーションを開発する。

### 1.2 対象ユーザー
- 個人利用（開発者本人）

### 1.3 対象データ範囲
- 第1期: 2001年〜2010年
- 第2期: 2015年〜現在

---

## 2. 機能要件

### 2.1 年度別分析機能

指定した年度の大会情報を一覧表示する。

| 項目 | 説明 |
|------|------|
| 大会出場組数 | 決勝進出コンビの総数 |
| 決勝出場コンビリスト | 出場コンビ名の一覧 |
| MCリスト | 司会者名 |
| 審査員リスト | 審査員名の一覧 |
| 笑神籤担当リスト | 笑神籤を引いた担当者名 |

#### 2.1.1 ファーストステージ
- 出場順
- コンビ別詳細
  - ネタ名
  - 各審査員の得点
  - 合計点数
  - 順位

#### 2.1.2 ファイナルステージ
- 出場順
- コンビ別詳細
  - ネタ名
  - 各審査員の得票数
  - 順位（最終結果）

---

### 2.2 コンビ別分析機能

指定したコンビの出場履歴・成績を表示する。

| 項目 | 説明 |
|------|------|
| 合計出場回数 | 決勝進出した回数 |
| ファイナル進出回数 | ファイナルステージに進出した回数 |
| 出場年度一覧 | 出場した年度のリスト |
| 平均順位 | 全出場年度の順位平均 |

#### 2.2.1 年度別成績
- ファーストステージ
  - ネタ名、各審査員の得点、合計点数、順位
- ファイナルステージ（進出時のみ）
  - ネタ名、得票数、順位

---

### 2.3 審査員別分析機能

指定した審査員の審査履歴・傾向を表示する。

| 項目 | 説明 |
|------|------|
| 出場年度一覧 | 審査員として参加した年度のリスト |
| 出場回数 | 審査員として参加した回数 |
| 全体平均点数 | 全審査を通じた平均点 |

#### 2.3.1 年度別統計
- 各年度の平均点数

---

### 2.4 期別分析機能

第1期・第2期それぞれの統計を表示する。

| 項目 | 説明 |
|------|------|
| 平均点数 | 期間内の全得点の平均 |
| 大会出場コンビ数合計 | 期間内の延べ出場コンビ数 |

---

## 3. 画面一覧

| 画面名 | パス（案） | 概要 |
|--------|-----------|------|
| トップページ | `/m1` | 年度選択、各分析機能への導線 |
| 年度別詳細 | `/m1/years/[year]` | 指定年度の大会詳細 |
| コンビ一覧 | `/m1/combis` | コンビ検索・一覧 |
| コンビ詳細 | `/m1/combis/[id]` | 指定コンビの成績詳細 |
| 審査員一覧 | `/m1/judges` | 審査員検索・一覧 |
| 審査員詳細 | `/m1/judges/[id]` | 指定審査員の審査履歴 |
| 期別統計 | `/m1/periods` | 第1期・第2期の比較統計 |

---

## 4. データモデル（概要）

### 4.1 主要エンティティ

```
Tournament（大会）
├── year: 開催年
├── period: 期（1 or 2）
├── mc: MC名
└── lottery_presenter: 笑神籤担当

Combi（コンビ）
├── name: コンビ名

Judge（審査員）
├── name: 審査員名

Performance（出演）
├── tournament_id
├── combi_id
├── stage: ステージ（first / final）
├── order: 出場順
├── neta_name: ネタ名
└── rank: 順位

Score（得点）
├── performance_id
├── judge_id
└── score: 点数（ファーストステージ）または票（ファイナル）
```

---

## 5. 非機能要件

### 5.1 技術スタック
- フロントエンド: Next.js（既存プロジェクトに統合）
- データ管理: 静的JSON

### 5.2 対応ブラウザ
- Chrome最新版（個人利用のため限定）

### 5.3 コーディング規約

#### アイコン使用ルール
- 絵文字は使用しない
- アイコンは`lucide-react`を使用する
- 例: `<Crown />`, `<Medal />` など

### 5.4 データ永続化方式の選定

#### 選定結果: 静的JSON

#### 比較検討

| 方式 | メリット | デメリット |
|------|----------|------------|
| **静的JSON** | シンプル、インフラ不要、Git管理可能、ビルド時に型チェック可能 | データ更新時に再ビルドが必要 |
| **RDB（PostgreSQL等）** | 複雑なクエリ対応、データ整合性保証 | インフラ構築・運用コスト、個人開発にはオーバースペック |
| **NoSQL（Firebase Firestore）** | リアルタイム更新、スケーラビリティ | 更新頻度が低いデータには不要、課金リスク |

#### 静的JSONを選定した理由

1. **データ特性との適合**
   - 更新頻度が極めて低い（年1回の大会終了後のみ）
   - データ量が限定的（約20年分、各年10組程度 = 数百レコード）
   - 読み取り専用（ユーザーによる編集機能なし）

2. **開発・運用の簡素化**
   - DBサーバーの構築・運用が不要
   - 環境変数や接続設定が不要
   - Gitでデータのバージョン管理が可能

3. **パフォーマンス**
   - ビルド時にデータが埋め込まれるためAPI呼び出し不要
   - データ量が少ないためメモリ上での結合処理も高速

#### データ構成

```
frontend/src/data/m1/
├── combis.json         # コンビマスタ
├── judges.json         # 審査員マスタ
├── tournaments.json    # 大会情報（審査員IDを含む）
├── performances.json   # 出演データ（大会ID、コンビIDを含む）
└── scores.json         # 得点データ（出演ID、審査員IDを含む）
```

#### リレーションの表現

IDによる参照でRDB同様のリレーションを実現する。

```json
// combis.json
[{ "id": "c001", "name": "笑い飯" }]

// performances.json
[{ "id": "p001", "tournamentId": "t2019", "combiId": "c001", ... }]

// scores.json
[{ "performanceId": "p001", "judgeId": "j001", "score": 98 }]
```

---

## 6. 今後の拡張案（スコープ外）

- グラフ・チャートによる可視化
- コンビ間の比較機能
- 審査員の採点傾向分析（辛口/甘口）
- データのインポート機能
